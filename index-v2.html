<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI é ­éƒ¨å‹•ä½œæ„Ÿæ¸¬ v2 (é–‹ç™¼ç‰ˆ - å®Œæ•´æ¨¡çµ„åŒ–)</title>
    
    <!-- 
      [é›¢ç·šç‰ˆè£½ä½œèªªæ˜]
      é›¢ç·šä½¿ç”¨æ™‚ï¼Œè«‹ç¢ºä¿ JS æª”æ¡ˆåœ¨åŒä¸€ç›®éŒ„ï¼Œä¸¦ä¿®æ”¹ä¸‹æ–¹çš„ src å¼•ç”¨ã€‚
    -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- å¤–éƒ¨æ¨£å¼è¡¨ -->
    <link rel="stylesheet" href="css/style.css">

    <!-- æ ¸å¿ƒæ¨¡çµ„ -->
    <script src="js/config.js"></script>
    <script src="js/AudioEngine.js"></script>
    <script src="js/CalibrationSystem.js"></script>
    <script src="js/FaceTracker.js"></script>
    <script src="js/main.js"></script>
    <script src="js/AccompanimentSystem.js"></script>
</head>
<body>

    <!-- éš±è—çš„æª”æ¡ˆä¸Šå‚³è¼¸å…¥æ¡† -->
    <input type="file" id="csv-input" accept=".csv" style="display:none" onchange="handleFileSelect(event)">

    <div id="start-screen" class="start-screen">
        <div class="mb-8 text-center">
            <h1 class="text-4xl font-bold text-white mb-2 font-chinese">AI é ­éƒ¨å‹•ä½œæ„Ÿæ¸¬</h1>
            <p class="text-gray-400">Head Motion Tracker</p>
        </div>
        <button id="start-btn" class="start-btn-large">â–¶ é»æ“Šé–‹å§‹ (å•Ÿå‹•éŸ³æ•ˆ)</button>
        <p class="mt-4 text-sm text-gray-500">é»æ“Šå¾ŒéŸ³æ•ˆå°‡è‡ªå‹•é–‹å•Ÿ</p>
    </div>

    <div class="camera-container">
        <div id="loader" class="loader">
            <div class="spinner"></div>
            <div>ç³»çµ±åˆå§‹åŒ–ä¸­...<br>
                <span style="font-size:0.8rem; color:#aaa;">
                    è«‹å…è¨±æ”å½±æ©Ÿæ¬Šé™<br>
                    (è‹¥ä¸€ç›´é¡¯ç¤ºæ­¤ç•«é¢ï¼Œä»£è¡¨ JS æª”æ¡ˆç¼ºå¤±)
                </span>
            </div>
        </div>

        <div class="canvas-wrapper">
            <video id="input_video" playsinline></video>
            <canvas id="output_canvas"></canvas>
            
            <!-- æ–°å¢ï¼šè‡‰éƒ¨å°å¼•æ¡† HTML -->
            <div id="face-guide" class="face-guide">
                <div class="face-guide-text">è«‹å°‡è‡‰éƒ¨å°æº–æ¡†ç·šä¸­å¤®<br><span style='font-size:0.7rem; color:#aaa'>(å¯æ»¾è¼ªèª¿æ•´å¤§å°)</span></div>
            </div>

            <!-- æ–°å¢ï¼šå’Œå¼¦é¡¯ç¤ºçœ‹æ¿ -->
            <div id="chord-display" class="chord-display"></div>

            <!-- å³ä¸Šè§’éŸ³é«˜æ•¸æ“šé¢æ¿ -->
            <div id="note-info" class="note-info-panel">
                <div class="text-[0.6rem] text-gray-400 uppercase tracking-wider mb-1">Current Pitch</div>
                <div id="current-note-name" class="note-main">--</div>
                <div id="current-solfege" class="note-sub">ç­‰å¾…æ¼”å¥...</div>
                <div id="current-freq" class="note-freq mt-1">0 Hz</div>
            </div>
            
            <div class="hud-overlay">
                <div class="corner tl"></div>
                <div class="corner tr"></div>
                <div class="corner bl"></div>
                <div class="corner br"></div>

                <div class="data-panel">
                    <div>YAW: <span id="val-yaw">0.00</span></div>
                    <div>PITCH: <span id="val-pitch">0.00</span></div>
                    <div style="margin-top:5px; font-size: 0.8rem; opacity: 0.7;">FPS: <span id="val-fps">0</span></div>
                    <div style="margin-top:5px; color: #fbbf24;" id="mode-indicator">æ¨¡å¼: å¯èª¿å¼åœ“åœˆè§¸ç™¼</div>
                    <div id="octave-indicator" class="octave-badge">ğŸ¹ éŸ³é«˜: æ¨™æº–</div>
                    <div style="margin-top:5px;">ç‹€æ…‹: <span id="trigger-state" class="text-green-400">å°±ç·’</span></div>
                </div>

                <div class="status-panel">
                    <div class="text-xs text-cyan-400 mb-1">DETECTED ACTION</div>
                    <div class="flex items-center justify-center">
                        <div id="status-text" class="status-text">WAITING...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ç¨ç«‹çš„ä¼´å¥æŒ‰éˆ• -->
        <button class="btn-base accomp-btn" onclick="toggleAccompPanel()">ğŸ¹ ä¼´å¥è¨­å®š</button>
        <button class="btn-base toggle-btn" onclick="toggleCalibration()">âš™ï¸ æ ¡æ­£èˆ‡è¨­å®š</button>
        
        <button id="sound-toggle" class="btn-base sound-btn" onclick="toggleSound()">
            <span>ğŸ”‡</span> é»æ“Šé–‹å•ŸéŸ³æ•ˆ (è«‹æª¢æŸ¥éœéŸ³éµ)
        </button>

        <div id="calib-panel" class="side-panel">
            <h3 class="text-lg font-bold mb-2 border-b border-gray-700 pb-2">æ ¡æ­£èˆ‡è¨­å®š</h3>
            
            <div class="mb-3 pb-2">
                <label class="text-xs text-blue-400 block mb-2 font-bold">ğŸ“ è¨­å®šæª” (Profile)</label>
                <div class="flex gap-2">
                    <button onclick="switchProfile(1)" id="profile-btn-1" class="profile-btn active">1</button>
                    <button onclick="switchProfile(2)" id="profile-btn-2" class="profile-btn">2</button>
                    <button onclick="switchProfile(3)" id="profile-btn-3" class="profile-btn">3</button>
                </div>
            </div>
            
            <div class="mode-switch">
                <button id="mode-rec-btn" onclick="setEditMode(false)" class="active-rec">ğŸ”´ éŒ„è£½ä½ç½®</button>
                <button id="mode-edit-btn" onclick="setEditMode(true)">ğŸ”µ ç·¨è¼¯åƒæ•¸</button>
            </div>

            <div id="rec-controls">
                <button onclick="setCenter()" class="mb-2 w-full bg-cyan-900/50 hover:bg-cyan-900 text-cyan-200 py-2 rounded text-xs border border-cyan-800 flex items-center justify-center gap-2">
                    <span>ğŸ¯</span> æ‰‹å‹•è¨­å®šç•¶å‰ç‚ºä¸­å¿ƒé»
                </button>

                <button id="range-btn" onclick="toggleRangeDetection()" class="mb-3 w-full bg-purple-900/50 hover:bg-purple-900 text-purple-200 py-2 rounded text-xs border border-purple-800 flex items-center justify-center gap-2">
                    <span>ğŸŒ€</span> é–‹å§‹åœ“å½¢ç¯„åœåµæ¸¬ (æ¨è–¦)
                </button>
                <p id="range-hint" class="text-[0.6rem] text-gray-400 mb-2 hidden">è«‹è¼•é¬†åœ°ç”¨é ­éƒ¨<b>è½‰å‹•ä¸€å€‹åœ“åœˆ</b>ï¼Œä¸ç”¨åˆ»æ„åˆ°æ¥µé™ã€‚</p>
            </div>

            <p id="grid-hint" class="text-xs text-gray-400">é»æ“Šä¸‹æ–¹æŒ‰éˆ•éŒ„è£½ä½ç½®ï¼š</p>
            <div class="grid-3x3">
                <button class="calib-btn" id="btn-1" onclick="handleGridClick(1, 'Do (1)')">1<small>Do</small></button>
                <button class="calib-btn" id="btn-2" onclick="handleGridClick(2, 'Re (2)')">2<small>Re</small></button>
                <button class="calib-btn" id="btn-3" onclick="handleGridClick(3, 'Mi (3)')">3<small>Mi</small></button>
                <button class="calib-btn" id="btn-4" onclick="handleGridClick(4, 'Fa (4)')">4<small>Fa</small></button>
                <button class="calib-btn" id="btn-5" onclick="handleGridClick(5, 'ç„¡ (5)')">5<small>ç„¡</small></button>
                <button class="calib-btn" id="btn-6" onclick="handleGridClick(6, 'So (6)')">6<small>So</small></button>
                <button class="calib-btn" id="btn-7" onclick="handleGridClick(7, 'La (7)')">7<small>La</small></button>
                <button class="calib-btn" id="btn-8" onclick="handleGridClick(8, 'Si (8)')">8<small>Si</small></button>
                <button class="calib-btn" id="btn-9" onclick="handleGridClick(9, 'High Do')">9<small>High Do</small></button>
            </div>

            <!-- å€‹åˆ¥è¨­å®šé¢æ¿ -->
            <div id="point-settings-panel" class="point-settings hidden">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-xs font-bold text-amber-400">è¨­å®š: <span id="selected-point-name">ç„¡</span></span>
                </div>
                
                <!-- æ–°å¢ï¼šåŸºéŸ³é¸æ“‡ -->
                <div class="mb-2">
                    <label class="text-[0.6rem] text-gray-400 block mb-1">ğŸµ è¨­å®šåŸºéŸ³ (Base Note)</label>
                    <select id="base-note-select" class="bg-gray-800 text-xs text-white p-1 rounded border border-gray-600 w-full">
                        <!-- Options generated by JS -->
                    </select>
                </div>
                
                <div class="mb-2">
                    <label class="text-[0.6rem] text-gray-400 block mb-1">å‡é™å¾®èª¿ (Semitone)</label>
                    <div class="flex gap-1">
                        <button onclick="setPointSemitone(-1)" id="semitone-flat-btn" class="semitone-btn">â™­</button>
                        <button onclick="setPointSemitone(0)" id="semitone-std-btn" class="semitone-btn active">â™®</button>
                        <button onclick="setPointSemitone(1)" id="semitone-sharp-btn" class="semitone-btn">â™¯</button>
                    </div>
                </div>

                <div>
                    <label class="text-[0.6rem] text-gray-400 block mb-1">å€‹åˆ¥åŠå¾‘: <span id="point-radius-val">40</span></label>
                    <input type="range" id="point-radius-slider" min="10" max="120" step="1" value="40" class="w-full h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer">
                </div>
            </div>
            
            <!-- å…¨å±€åœ“åœˆå¤§å° (å·²éš±è—) -->
            <div class="mt-4 pt-2 border-t border-gray-700 hidden">
                <label class="text-xs text-green-400 block mb-2 font-bold">ğŸ¯ å…¨å±€åœ“åœˆå¤§å°</label>
                <div class="flex items-center gap-2">
                    <input type="range" id="radius-slider" min="10" max="120" step="1" value="40" class="flex-grow">
                    <span id="radius-val" class="text-xs text-gray-300 w-6">40</span>
                </div>
            </div>

            <div class="mt-2">
                <label class="text-xs text-gray-400 block mb-2">åæ‡‰éˆæ•åº¦</label>
                <input type="range" id="speed-slider" min="0.02" max="0.5" step="0.01" value="0.15">
            </div>

            <!-- éŸ³æ•ˆè¨­å®šå€å¡Š -->
            <div class="section-title">ğŸµ éŸ³æ•ˆè¨­å®š</div>
            
            <div class="flex items-center justify-between mb-2 p-2 bg-gray-800 rounded border border-gray-600">
                <label class="text-xs text-gray-300 font-bold cursor-pointer" for="return-center-toggle">å›ä¸­é‡ç½® (å–®æ¬¡è§¸ç™¼)</label>
                <!-- ç§»é™¤ checked å±¬æ€§ï¼Œé è¨­ä¸é–‹å•Ÿ -->
                <input type="checkbox" id="return-center-toggle" class="w-4 h-4 accent-purple-500 cursor-pointer">
            </div>

            <div class="flex flex-col gap-2">
                <div class="flex flex-col gap-1">
                    <label class="text-xs text-gray-300">æ¨‚å™¨:</label>
                    <select id="instrument-select" class="bg-gray-800 text-xs text-white p-1 rounded border border-gray-600">
                        <option value="piano">ğŸ¹ æ¨¡æ“¬é‹¼ç´</option>
                        <option value="8bit">ğŸ‘¾ 8-Bit é›»å­éŸ³</option>
                        <option value="flute">ğŸŒ¬ï¸ é•·ç¬›</option>
                    </select>
                </div>
                <div class="flex flex-col gap-1">
                    <div class="flex justify-between"><label class="text-[0.6rem] text-gray-400">éŸ³é‡:</label><span id="vol-val" class="text-[0.6rem] text-gray-300">50%</span></div>
                    <input type="range" id="vol-slider" min="0" max="100" step="1" value="50" class="accent-purple-500">
                </div>
                <div class="flex flex-col gap-1">
                    <div class="flex justify-between"><label class="text-[0.6rem] text-gray-400">é•·åº¦:</label><span id="dur-val" class="text-[0.6rem] text-gray-300">1.5s</span></div>
                    <input type="range" id="dur-slider" min="0.1" max="3.0" step="0.1" value="1.5" class="accent-purple-500">
                </div>
            </div>

            <!-- æ–°å¢å˜´éƒ¨æ§åˆ¶å€å¡Š (å·²æ¢å¾©é¡¯ç¤º) -->
            <div>
                <div class="section-title">ğŸ‘„ å˜´éƒ¨æ§åˆ¶ (å…«åº¦åˆ‡æ›)</div>
                <div class="flex flex-col gap-2 mb-2">
                    <div class="flex items-center justify-between">
                        <label class="text-xs text-gray-300" for="mouth-enable-check">å•Ÿç”¨å˜´éƒ¨å…«åº¦æ§åˆ¶</label>
                        <input type="checkbox" id="mouth-enable-check" checked class="w-4 h-4 accent-pink-500">
                    </div>
                    <div class="flex flex-col gap-1">
                        <label class="text-xs text-gray-400">è§¸ç™¼å‹•ä½œ:</label>
                        <select id="mouth-trigger-mode" class="bg-gray-800 text-xs text-white p-1 rounded border border-gray-600">
                            <option value="close" selected>ğŸ¤ é–‰å˜´ç¬é–“åˆ‡æ› (é è¨­)</option>
                            <option value="open">ğŸ˜® å¼µå˜´ç¬é–“åˆ‡æ›</option>
                        </select>
                    </div>
                </div>
            </div>

            <div class="debug-checkbox mt-4">
                <input type="checkbox" id="show-zones" checked onchange="toggleZones()">
                <label for="show-zones" class="text-yellow-200">é¡¯ç¤ºè§¸ç™¼åœˆ</label>
            </div>
            <!-- æ–°å¢ï¼šæ§åˆ¶å°å¼•æ¡†çš„é–‹é—œ -->
            <div class="debug-checkbox">
                <input type="checkbox" id="show-guide" checked onchange="toggleGuide()">
                <label for="show-guide" class="text-cyan-200">é¡¯ç¤ºé¢éƒ¨å°å¼•æ¡†</label>
            </div>
            <div class="debug-checkbox">
                <input type="checkbox" id="show-debug" checked onchange="toggleDebug()">
                <label for="show-debug">é¡¯ç¤ºè»Œè·¡ç´…é» & å˜´éƒ¨åµæ¸¬</label>
            </div>
            
            <div class="mt-4 border-t border-gray-700 pt-3 flex gap-2">
                <button onclick="saveConfig()" class="flex-1 bg-green-900/50 hover:bg-green-900 text-green-200 py-1 px-2 rounded text-xs border border-green-800">ğŸ’¾ å„²å­˜</button>
                <button onclick="loadConfig()" class="flex-1 bg-blue-900/50 hover:bg-blue-900 text-blue-200 py-1 px-2 rounded text-xs border border-blue-800">ğŸ“‚ è®€å–</button>
            </div>
            <div class="mt-2 flex gap-2">
                 <button onclick="exportCSV()" class="flex-1 bg-yellow-900/50 hover:bg-yellow-900 text-yellow-200 py-1 px-2 rounded text-xs border border-yellow-800">ğŸ“¤ åŒ¯å‡º CSV</button>
                 <button onclick="importCSV()" class="flex-1 bg-cyan-900/50 hover:bg-cyan-900 text-cyan-200 py-1 px-2 rounded text-xs border border-cyan-800">ğŸ“¥ åŒ¯å…¥ CSV</button>
            </div>
            <button onclick="resetCalibration()" class="mt-2 w-full bg-red-900/50 hover:bg-red-900 text-red-200 py-2 rounded text-xs border border-red-800">ğŸ—‘ï¸ é‡ç½®ç•¶å‰è¨­å®š</button>
        </div>

        <!-- ç¨ç«‹çš„ä¼´å¥é¢æ¿ -->
        <div id="accomp-panel" class="side-panel">
            <h3 class="text-lg font-bold mb-2 border-b border-gray-700 pb-2">ğŸ¹ ä¼´å¥è¨­å®š</h3>
            <!-- è‡ªå‹•å’Œå¼¦ä¼´å¥å€å¡Š (Auto Chords) -->
            <div class="section-title">è‡ªå‹•å’Œå¼¦ä¼´å¥ (Auto Chords)</div>
            <div class="flex flex-col gap-2 p-2 bg-gray-800 rounded border border-gray-600">
                <div class="flex flex-col gap-1">
                    <label class="text-xs text-gray-400">é¸æ“‡æ›²é¢¨/é€²è¡Œ:</label>
                    <select id="chord-prog-select" class="bg-gray-700 text-xs text-white p-1 rounded border border-gray-500">
                        <option value="none">-- é—œé–‰ --</option>
                        <option value="metronome_4" selected>â± ç´”ç¯€æ‹å™¨ (4/4æ‹)</option>
                        <option value="metronome_3">â± ç´”ç¯€æ‹å™¨ (3/4æ‹)</option>
                        <!-- æ›´æ–°é¸å–®åç¨±ç‚º F å¤§èª¿ -->
                        <option value="amazing_grace">ğŸ™ å¥‡ç•°æ©å…¸ (3/4æ‹, Få¤§èª¿)</option>
                        <option value="pop_c">ğŸ¸ æµè¡Œ C å¤§èª¿ (4/4æ‹, C-G-Am-F)</option>
                        <option value="canon">ğŸ» å¡è¾²é€²è¡Œ (4/4æ‹)</option>
                        <option value="basic_1451">ğŸ¼ åŸºç¤ I-IV-V-I (4/4æ‹)</option>
                    </select>
                </div>
                
                <!-- New Section Selector -->
                <div id="section-select-container" class="flex flex-col gap-1 mt-1 hidden">
                    <label class="text-[0.6rem] text-gray-400">ç·´ç¿’æ®µè½ (Practice Section):</label>
                    <select id="section-select" class="bg-gray-700 text-xs text-white p-1 rounded border border-gray-500">
                        <!-- Options populated by JS -->
                    </select>
                </div>

                <div class="flex flex-col gap-1 mt-1">
                    <label class="text-[0.6rem] text-gray-400">ä¼´å¥éŸ³è‰²:</label>
                    <select id="chord-instrument-select" class="bg-gray-700 text-xs text-white p-1 rounded border border-gray-500">
                        <option value="soft_pad">â˜ï¸ æŸ”å’Œå¢ŠéŸ³ (Soft Pad)</option>
                        <option value="piano" selected>ğŸ¹ é›»é‹¼ç´ (E.Piano)</option> <!-- é è¨­æ”¹ç‚ºé›»é‹¼ç´ï¼Œæ•ˆæœè¼ƒæ˜é¡¯ -->
                        <option value="strings">ğŸ» åˆæˆå¼¦æ¨‚ (Synth Strings)</option>
                        <option value="pluck">ğŸ¸ æ’¥å¼¦ (Pluck)</option>
                    </select>
                </div>

                <!-- æ–°å¢ï¼šåˆ†è§£å’Œå¼¦é–‹é—œ -->
                <div class="flex items-center gap-2 mt-2 bg-gray-700/50 p-1 rounded">
                    <input type="checkbox" id="arpeggio-check" class="w-4 h-4 accent-pink-500 cursor-pointer">
                    <label for="arpeggio-check" class="text-xs text-gray-200 cursor-pointer font-bold">åˆ†è§£å’Œå¼¦ (Arpeggio)</label>
                </div>

                <!-- æ–°å¢ï¼šç¯€æ‹å™¨é–‹é—œ -->
                <div class="flex items-center gap-2 mt-1 bg-gray-700/50 p-1 rounded">
                    <input type="checkbox" id="metronome-check" class="w-4 h-4 accent-red-500 cursor-pointer">
                    <label for="metronome-check" class="text-xs text-gray-200 cursor-pointer font-bold flex-1">é–‹å•Ÿç¯€æ‹å™¨ (Click)</label>
                    <div id="metronome-light" class="metronome-light" title="ç¯€æ‹æŒ‡ç¤ºç‡ˆ"></div>
                </div>
                
                <div class="flex gap-2 items-center mt-2">
                    <button onclick="toggleAutoChords()" id="chord-play-btn" class="flex-1 bg-green-800/60 hover:bg-green-700 text-white py-1 rounded text-xs border border-green-600">â–¶ é–‹å§‹ä¼´å¥</button>
                </div>

                <div class="flex items-center justify-between mt-1">
                    <label class="text-[0.6rem] text-gray-400">é€Ÿåº¦ (BPM): <span id="bpm-val" class="text-gray-300">100</span></label>
                </div>
                <input type="range" id="bpm-slider" min="40" max="180" step="1" value="100" class="accent-pink-500 h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer">

                <div class="flex items-center justify-between mt-1">
                    <label class="text-[0.6rem] text-gray-400">ä¼´å¥éŸ³é‡:</label>
                    <span id="chord-vol-val" class="text-[0.6rem] text-gray-300">30%</span>
                </div>
                <input type="range" id="chord-vol-slider" min="0" max="100" step="1" value="30" class="accent-cyan-500 h-1 bg-gray-600 rounded-lg appearance-none cursor-pointer">
            </div>
        </div>
    </div>

    <script>
        // å®‰å…¨æª¢æŸ¥ï¼šç¢ºä¿ JS åº«è¼‰å…¥
        window.onerror = function(message, source, lineno, colno, error) {
            console.error("Error:", message);
            if (message.includes("FaceMesh") || message.includes("Camera")) {
                const loader = document.getElementById('loader');
                if(loader) loader.innerHTML = `<div style="color:red; text-align:center;">ç¨‹å¼åº«è¼‰å…¥å¤±æ•—<br>è«‹ç¢ºèª JS æª”æ¡ˆæ˜¯å¦å­˜åœ¨</div>`;
            }
        };

        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusText = document.getElementById('status-text');
        const loader = document.getElementById('loader');
        
        // Panels
        const calibPanel = document.getElementById('calib-panel');
        const accompPanel = document.getElementById('accomp-panel'); 
        
        const modeIndicator = document.getElementById('mode-indicator');
        const soundBtn = document.getElementById('sound-toggle');
        const showDebugCheck = document.getElementById('show-debug');
        const showZonesCheck = document.getElementById('show-zones');
        const showGuideCheck = document.getElementById('show-guide'); 
        const faceGuide = document.getElementById('face-guide'); 
        const chordDisplay = document.getElementById('chord-display'); 
        const speedSlider = document.getElementById('speed-slider');
        const radiusSlider = document.getElementById('radius-slider');
        const radiusValDisplay = document.getElementById('radius-val');
        const rangeBtn = document.getElementById('range-btn');
        const rangeHint = document.getElementById('range-hint');
        const triggerStateText = document.getElementById('trigger-state');
        const octaveIndicator = document.getElementById('octave-indicator');
        const startScreen = document.getElementById('start-screen');
        const startBtn = document.getElementById('start-btn');
        const csvInput = document.getElementById('csv-input');
        
        // New UI for Note Info
        const currentNoteNameDisplay = document.getElementById('current-note-name');
        const currentSolfegeDisplay = document.getElementById('current-solfege');
        const currentFreqDisplay = document.getElementById('current-freq');
        const noteInfoPanel = document.getElementById('note-info');

        // Edit Mode UI
        const pointSettingsPanel = document.getElementById('point-settings-panel');
        const selectedPointName = document.getElementById('selected-point-name');
        const pointRadiusSlider = document.getElementById('point-radius-slider');
        const pointRadiusVal = document.getElementById('point-radius-val');
        const gridHint = document.getElementById('grid-hint');
        const recControls = document.getElementById('rec-controls');
        const modeRecBtn = document.getElementById('mode-rec-btn');
        const modeEditBtn = document.getElementById('mode-edit-btn');
        const baseNoteSelect = document.getElementById('base-note-select');

        // Sound Setting UI Elements
        const returnCenterToggle = document.getElementById('return-center-toggle');
        const instrumentSelect = document.getElementById('instrument-select');
        const volSlider = document.getElementById('vol-slider');
        const volValDisplay = document.getElementById('vol-val');
        const durSlider = document.getElementById('dur-slider');
        const durValDisplay = document.getElementById('dur-val');

        // Auto Chords UI Elements
        const chordProgSelect = document.getElementById('chord-prog-select');
        const sectionSelectContainer = document.getElementById('section-select-container');
        const sectionSelect = document.getElementById('section-select');
        const chordPlayBtn = document.getElementById('chord-play-btn');
        const bpmSlider = document.getElementById('bpm-slider');
        const bpmVal = document.getElementById('bpm-val');
        const chordVolSlider = document.getElementById('chord-vol-slider');
        const chordVolVal = document.getElementById('chord-vol-val');
        const chordInstrumentSelect = document.getElementById('chord-instrument-select');
        const metronomeCheck = document.getElementById('metronome-check');
        const metronomeLight = document.getElementById('metronome-light');

        // Mouth Control UI Elements
        const mouthEnableCheck = document.getElementById('mouth-enable-check');
        const mouthTriggerModeSelect = document.getElementById('mouth-trigger-mode');

        const valYaw = document.getElementById('val-yaw');
        const valPitch = document.getElementById('val-pitch');
        const valFps = document.getElementById('val-fps');
        
        let lastTime = 0;
        let frameCount = 0;
        
        let rawYaw = 0, rawPitch = 0;
        let smoothYaw = 0, smoothPitch = 0;
        let centerOffset = { yaw: 0, pitch: 0.45 };
        
        let smoothingFactor = 0.15; 
        speedSlider.addEventListener('input', (e) => { smoothingFactor = parseFloat(e.target.value); });

        let defaultTriggerRadius = 40;
        radiusSlider.addEventListener('input', (e) => { 
            defaultTriggerRadius = parseInt(e.target.value); 
            radiusValDisplay.innerText = defaultTriggerRadius;
            for(let id in calibrationData) {
                calibrationData[id].radius = defaultTriggerRadius;
            }
        });

        let soundSettings = {
            returnToCenter: false, 
            instrument: 'piano',
            volume: 0.5,
            duration: 1.5
        };

        returnCenterToggle.addEventListener('change', (e) => { soundSettings.returnToCenter = e.target.checked; });
        instrumentSelect.addEventListener('change', (e) => { 
            soundSettings.instrument = e.target.value; 
            playNote(523.25, null, true); 
        });
        volSlider.addEventListener('input', (e) => { 
            soundSettings.volume = parseInt(e.target.value) / 100; 
            volValDisplay.innerText = `${e.target.value}%`;
        });
        volSlider.addEventListener('change', () => playNote(523.25, null, true));
        durSlider.addEventListener('input', (e) => { 
            soundSettings.duration = parseFloat(e.target.value); 
            durValDisplay.innerText = `${e.target.value}s`;
        });

        // --- Auto Chords Logic (ä½¿ç”¨æ¨¡çµ„åŒ–çš„ AccompanimentSystem) ---
        const accompaniment = new AccompanimentSystem({
            bpm: 100,
            volume: 0.3,
            instrument: 'soft_pad',
            metronomeEnabled: false,
            isArpeggio: false,

            // å°ç¯€è®Šæ›´å›èª¿ - æ›´æ–° UI é¡¯ç¤º
            onBarChange: (data) => {
                let melodyHint = '';
                if (data.hint) {
                    melodyHint = `<div style="font-size: 1.8rem; color: #00ffcc; margin-top: 8px; text-shadow: 0 0 15px rgba(0, 255, 204, 0.8); font-family: 'Share Tech Mono', monospace;">${data.hint}</div>`;
                }
                const displayBarNum = data.measureNumber || data.barIndex + 1;
                chordDisplay.innerHTML = `
                    <div style="font-size: 1rem; color: #9ca3af; text-shadow: none; margin-bottom: -5px;">ç¬¬ ${displayBarNum} å°ç¯€</div>
                    <div style="line-height: 1;">${data.chord === 'NC' ? 'Metronome' : data.chord}</div>
                    ${melodyHint}
                `;
            },

            // ç¯€æ‹å™¨å›èª¿ - é–ƒçˆç‡ˆè™Ÿ
            onMetronomeBeat: (data) => {
                flashMetronomeLight(data.isAccent);
            },

            // ç‹€æ…‹è®Šæ›´å›èª¿ - æ›´æ–°æŒ‰éˆ•
            onStateChange: (data) => {
                if (data.state === 'playing') {
                    chordPlayBtn.innerText = "â¹ åœæ­¢ä¼´å¥";
                    chordPlayBtn.classList.replace("bg-green-800/60", "bg-red-800/60");
                    chordPlayBtn.classList.replace("border-green-600", "border-red-600");
                    chordDisplay.classList.add('active');
                } else {
                    chordPlayBtn.innerText = "â–¶ é–‹å§‹ä¼´å¥";
                    chordPlayBtn.classList.replace("bg-red-800/60", "bg-green-800/60");
                    chordPlayBtn.classList.replace("border-red-600", "border-green-600");
                    chordDisplay.classList.remove('active');
                    chordDisplay.innerText = "";
                }
            }
        });

        // UI äº‹ä»¶ç¶å®š
        chordInstrumentSelect.addEventListener('change', (e) => {
            accompaniment.setInstrument(e.target.value);
        });

        chordProgSelect.addEventListener('change', (e) => {
            const key = e.target.value;
            const sections = accompaniment.selectProgression(key);

            if (sections) {
                sectionSelectContainer.classList.remove('hidden');
                sectionSelect.innerHTML = '';
                sections.forEach((sec, idx) => {
                    const opt = document.createElement('option');
                    opt.value = idx;
                    opt.innerText = sec.name;
                    sectionSelect.appendChild(opt);
                });
            } else {
                sectionSelectContainer.classList.add('hidden');
            }
        });

        sectionSelect.addEventListener('change', (e) => {
            accompaniment.selectSection(parseInt(e.target.value) || 0);
        });

        bpmSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value);
            bpmVal.innerText = value;
            accompaniment.setBpm(value);
        });

        chordVolSlider.addEventListener('input', (e) => {
            const value = parseInt(e.target.value) / 100;
            chordVolVal.innerText = `${e.target.value}%`;
            accompaniment.setVolume(value);
        });

        document.getElementById('arpeggio-check').addEventListener('change', (e) => {
            accompaniment.setArpeggio(e.target.checked);
        });

        metronomeCheck.addEventListener('change', (e) => {
            accompaniment.setMetronome(e.target.checked);
        });

        function toggleAutoChords() {
            const key = chordProgSelect.value;
            if (key === 'none' && !accompaniment.isPlaying) {
                showFeedback("âš ï¸ è«‹å…ˆé¸æ“‡æ›²é¢¨");
                return;
            }

            // ç¢ºä¿ audioCtx å·²åˆå§‹åŒ–ä¸¦å‚³çµ¦æ¨¡çµ„
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
            accompaniment.setAudioContext(audioCtx);

            accompaniment.toggle(key);
        }

        // ç¯€æ‹å™¨ç‡ˆè™Ÿé–ƒçˆï¼ˆä¿ç•™åŸæœ‰è¦–è¦ºæ•ˆæœï¼‰
        function flashMetronomeLight(isAccent) {
            metronomeLight.classList.add('active');
            if (isAccent) {
                metronomeLight.style.background = '#00ffcc';
                metronomeLight.style.boxShadow = '0 0 15px #00ffcc';
            } else {
                metronomeLight.style.background = '#ef4444';
                metronomeLight.style.boxShadow = '0 0 10px #ef4444';
            }
            setTimeout(() => {
                metronomeLight.classList.remove('active');
                metronomeLight.style.background = '#334155';
                metronomeLight.style.boxShadow = 'none';
            }, 100);
        }

        // ç‚ºäº†å‘å¾Œç›¸å®¹ï¼Œä¿ç•™é€™äº›è®Šæ•¸çš„å­˜å–
        function getAccompanimentState() {
            return accompaniment.getState();
        }

        // Mouth Control Settings
        let mouthControlEnabled = true;
        let mouthTriggerMode = 'close'; 

        mouthEnableCheck.addEventListener('change', (e) => { mouthControlEnabled = e.target.checked; });
        mouthTriggerModeSelect.addEventListener('change', (e) => { mouthTriggerMode = e.target.value; });

        let lastDetectedId = null; 
        let isArmed = true; 

        let isDebugVisible = true;
        let isZonesVisible = true;
        let calibrationData = {}; 
        let faceGuideScale = 1.0; 

        let isRangeDetecting = false;
        let rangeMinYaw = Infinity, rangeMaxYaw = -Infinity;
        let rangeMinPitch = Infinity, rangeMaxPitch = -Infinity;
        let rangeTrace = [];

        let isDragging = false;
        let draggedPointId = null;

        let isEditMode = false;
        let selectedPointId = null;

        let isHighOctave = false;
        let wasMouthOpen = false;
        const MOUTH_OPEN_THRESHOLD = 0.08; 

        let audioCtx = null;
        let isSoundEnabled = false; 

        let currentProfileIndex = 1;
        const STORAGE_KEY_PREFIX = 'head_tracker_config_v11_profile_';

        function switchProfile(index) {
            for (let i = 1; i <= 3; i++) {
                const btn = document.getElementById(`profile-btn-${i}`);
                if (i === index) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }
            currentProfileIndex = index;
            loadConfig();
            showFeedback(`ğŸ“‚ å·²åˆ‡æ›è‡³è¨­å®šæª” ${index}`);
        }

        // --- Music Logic Constants ---
        const DEFAULT_BASE_MIDI = {
            1: 60, 2: 62, 3: 64, 4: 65, 5: null, 6: 67, 7: 69, 8: 71, 9: 72
        };
        const SOLFEGE_MAP = {
            1: "Do", 2: "Re", 3: "Mi", 4: "Fa", 5: "Rest", 6: "So", 7: "La", 8: "Si", 9: "Do"
        };
        
        const NOTE_FREQS = {
            1: 261.63, // C4
            2: 293.66, // D4
            3: 329.63, // E4
            4: 349.23, // F4
            5: 0,      // Rest
            6: 392.00, // G4
            7: 440.00, // A4
            8: 493.88, // B4
            9: 523.25  // C5
        };
        
        const NOTE_NAMES = {
            1: "Do", 2: "Re", 3: "Mi", 4: "Fa", 5: "Center", 6: "So", 7: "La", 8: "Si", 9: "High Do"
        };

        const NOTE_STRS = ['C', 'Câ™¯', 'D', 'Dâ™¯', 'E', 'F', 'Fâ™¯', 'G', 'Gâ™¯', 'A', 'Aâ™¯', 'B'];

        // Note Selection Options (C3 to C5)
        const NOTE_OPTIONS = [];
        for(let m=48; m<=72; m++) {
            const noteIndex = m % 12;
            const octave = Math.floor(m / 12) - 1;
            const name = NOTE_STRS[noteIndex] + octave;
            NOTE_OPTIONS.push({ midi: m, name: name });
        }
        NOTE_OPTIONS.push({ midi: -1, name: "ç„¡è² (Rest)" });

        // Populate Dropdown
        NOTE_OPTIONS.forEach(opt => {
            const el = document.createElement('option');
            el.value = opt.midi;
            el.innerText = opt.name;
            baseNoteSelect.appendChild(el);
        });

        baseNoteSelect.addEventListener('change', (e) => {
            if (selectedPointId && calibrationData[selectedPointId]) {
                const midi = parseInt(e.target.value);
                calibrationData[selectedPointId].baseMidi = (midi === -1) ? null : midi;
                saveConfig();
                playNote(0, selectedPointId, true); // Preview
            }
        });


        document.body.addEventListener('touchstart', function() {
            if (audioCtx && audioCtx.state === 'suspended') { audioCtx.resume(); }
        }, { once: true, passive: true });
        
        document.body.addEventListener('click', function() {
            if (audioCtx && audioCtx.state === 'suspended') { audioCtx.resume(); }
        }, { once: true });

        startBtn.addEventListener('click', async () => {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') await audioCtx.resume();
            isSoundEnabled = true;
            soundBtn.innerHTML = "<span>ğŸ”Š</span> éŸ³æ•ˆå·²é–‹å•Ÿ";
            soundBtn.classList.add('active');
            startScreen.style.opacity = '0';
            setTimeout(() => { startScreen.style.display = 'none'; }, 500);
            playNote(523.25, null, true);
            
            if(showGuideCheck.checked) {
                faceGuide.classList.add('active');
                setTimeout(() => {
                    if (faceGuide.classList.contains('active')) {
                        faceGuide.classList.remove('active');
                        showGuideCheck.checked = false; 
                    }
                }, 15000);
            }
        });

        function getLogicalPos(evt, canvas) {
            const rect = canvas.getBoundingClientRect();
            const clientX = evt.clientX || (evt.touches && evt.touches[0].clientX);
            const clientY = evt.clientY || (evt.touches && evt.touches[0].clientY);
            const visualX = clientX - rect.left;
            const visualY = clientY - rect.top;
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const logicalX = (rect.width - visualX) * scaleX; 
            const logicalY = visualY * scaleY;
            return { x: logicalX, y: logicalY };
        }

        function handleStart(evt) {
            if (!isDebugVisible && !isZonesVisible) return;
            const pos = getLogicalPos(evt, canvasElement);
            for (const [id, data] of Object.entries(calibrationData)) {
                 const cx = mapToCanvas(data.yaw, true, canvasElement.width, canvasElement.height);
                 const cy = mapToCanvas(data.pitch, false, canvasElement.width, canvasElement.height);
                 const r = data.radius || defaultTriggerRadius;
                 const dist = Math.sqrt((pos.x - cx)**2 + (pos.y - cy)**2);
                 if (dist < r) { 
                     isDragging = true; draggedPointId = id; canvasElement.style.cursor = 'grabbing'; 
                     if(isEditMode) selectPoint(id);
                     break;
                 }
            }
        }

        function handleMove(evt) {
            const pos = getLogicalPos(evt, canvasElement);
            if (isDragging && draggedPointId) {
                if (evt.preventDefault) evt.preventDefault();
                const w = canvasElement.width;
                const h = canvasElement.height;
                const newYaw = (pos.x / w - 0.5); 
                const newPitch = (pos.y / h - 0.5);
                calibrationData[draggedPointId].yaw = newYaw;
                calibrationData[draggedPointId].pitch = newPitch;
            } else if (isDebugVisible || isZonesVisible) {
                let hovering = false;
                for (const [id, data] of Object.entries(calibrationData)) {
                     const cx = mapToCanvas(data.yaw, true, canvasElement.width, canvasElement.height);
                     const cy = mapToCanvas(data.pitch, false, canvasElement.width, canvasElement.height);
                     const r = data.radius || defaultTriggerRadius;
                     const dist = Math.sqrt((pos.x - cx)**2 + (pos.y - cy)**2);
                     if (dist < r) hovering = true;
                }
                canvasElement.style.cursor = hovering ? 'grab' : 'default';
            }
        }

        function handleEnd() { isDragging = false; draggedPointId = null; canvasElement.style.cursor = 'default'; }

        function handleWheel(evt) {
            let handled = false;
            if (isZonesVisible) {
                const pos = getLogicalPos(evt, canvasElement);
                let hoveredId = null;
                for (const [id, data] of Object.entries(calibrationData)) {
                     const cx = mapToCanvas(data.yaw, true, canvasElement.width, canvasElement.height);
                     const cy = mapToCanvas(data.pitch, false, canvasElement.width, canvasElement.height);
                     const r = data.radius || defaultTriggerRadius;
                     const dist = Math.sqrt((pos.x - cx)**2 + (pos.y - cy)**2);
                     if (dist < r) { hoveredId = id; break; }
                }
                
                if (hoveredId) {
                    evt.preventDefault();
                    const delta = Math.sign(evt.deltaY) * -5;
                    let newR = (calibrationData[hoveredId].radius || defaultTriggerRadius) + delta;
                    newR = Math.max(10, Math.min(200, newR));
                    calibrationData[hoveredId].radius = newR;
                    if(selectedPointId == hoveredId) {
                        pointRadiusSlider.value = newR;
                        pointRadiusVal.innerText = newR;
                    }
                    handled = true; 
                    return;
                }
            }

            if (!handled && faceGuide && faceGuide.classList.contains('active')) {
                evt.preventDefault();
                const delta = Math.sign(evt.deltaY) * -0.1; 
                faceGuideScale += delta;
                faceGuideScale = Math.max(0.5, Math.min(3.0, faceGuideScale)); 
                faceGuide.style.transform = `translate(-50%, -50%) scale(${faceGuideScale})`;
            }
        }

        canvasElement.addEventListener('mousedown', handleStart);
        canvasElement.addEventListener('mousemove', handleMove);
        canvasElement.addEventListener('mouseup', handleEnd);
        canvasElement.addEventListener('mouseleave', handleEnd);
        canvasElement.addEventListener('touchstart', handleStart, {passive: false});
        canvasElement.addEventListener('touchmove', handleMove, {passive: false});
        canvasElement.addEventListener('touchend', handleEnd);
        canvasElement.addEventListener('wheel', handleWheel, {passive: false});

        function saveConfig() {
            const config = { calibrationData, centerOffset, defaultTriggerRadius, smoothingFactor, soundSettings, mouthControlEnabled, mouthTriggerMode };
            try {
                const key = STORAGE_KEY_PREFIX + currentProfileIndex;
                localStorage.setItem(key, JSON.stringify(config));
                showFeedback(`âœ… è¨­å®šæª” ${currentProfileIndex} å·²å„²å­˜ï¼`);
            } catch (e) { showFeedback("âŒ å„²å­˜å¤±æ•—"); }
        }

        function loadConfig() {
            calibrationData = {};
            centerOffset = { yaw: 0, pitch: 0.45 };
            defaultTriggerRadius = 40;
            radiusSlider.value = 40;
            radiusValDisplay.innerText = 40;
            
            const key = STORAGE_KEY_PREFIX + currentProfileIndex;
            const json = localStorage.getItem(key);
            if (json) {
                try {
                    const config = JSON.parse(json);
                    if (config.calibrationData) calibrationData = config.calibrationData;
                    if (config.centerOffset) centerOffset = config.centerOffset;
                    if (config.defaultTriggerRadius) {
                        defaultTriggerRadius = config.defaultTriggerRadius;
                        radiusSlider.value = defaultTriggerRadius;
                        radiusValDisplay.innerText = defaultTriggerRadius;
                    }
                    if (config.smoothingFactor) {
                        smoothingFactor = config.smoothingFactor;
                        speedSlider.value = smoothingFactor;
                    }
                    if (config.soundSettings) {
                        soundSettings = config.soundSettings;
                        if(soundSettings.returnToCenter === undefined) soundSettings.returnToCenter = false;
                        returnCenterToggle.checked = soundSettings.returnToCenter;
                        instrumentSelect.value = soundSettings.instrument;
                        volSlider.value = soundSettings.volume * 100;
                        volValDisplay.innerText = `${Math.round(soundSettings.volume * 100)}%`;
                        durSlider.value = soundSettings.duration;
                        durValDisplay.innerText = `${soundSettings.duration}s`;
                    }
                    if (config.mouthControlEnabled !== undefined) {
                        mouthControlEnabled = config.mouthControlEnabled;
                        mouthEnableCheck.checked = mouthControlEnabled;
                    }
                    if (config.mouthTriggerMode !== undefined) {
                        mouthTriggerMode = config.mouthTriggerMode;
                        mouthTriggerModeSelect.value = mouthTriggerMode;
                    }

                    document.querySelectorAll('.calib-btn').forEach(btn => btn.classList.remove('recorded'));
                    for (let id in calibrationData) {
                        const btn = document.getElementById(`btn-${id}`);
                        if(btn) btn.classList.add('recorded');
                    }
                } catch (e) { showFeedback("âŒ è®€å–å¤±æ•—"); }
            } else {
                document.querySelectorAll('.calib-btn').forEach(btn => btn.classList.remove('recorded'));
                showFeedback(`â„¹ï¸ è¨­å®šæª” ${currentProfileIndex} ç‚ºç©º`);
            }
            updateModeDisplay();
            selectedPointId = null;
            pointSettingsPanel.classList.add('hidden');
            document.querySelectorAll('.calib-btn').forEach(btn => btn.classList.remove('selected'));
        }

        function importCSV() {
            csvInput.click();
        }

        function handleFileSelect(evt) {
            const file = evt.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const text = e.target.result;
                    parseCSV(text);
                } catch (error) {
                    console.error(error);
                    showFeedback("âŒ æª”æ¡ˆè§£æå¤±æ•—");
                }
                csvInput.value = '';
            };
            reader.readAsText(file);
        }

        function parseCSV(text) {
            const lines = text.split(/\r\n|\n/);
            let isDataSection = false;
            
            let newCenterOffset = { ...centerOffset };
            let newSmoothing = smoothingFactor;
            let newTriggerRadius = defaultTriggerRadius;
            let newSoundSettings = { ...soundSettings };
            let newCalibrationData = {};
            let newMouthEnabled = mouthControlEnabled;
            let newMouthTrigger = mouthTriggerMode;

            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                if (line.startsWith("ID,Yaw,Pitch")) {
                    isDataSection = true;
                    continue;
                }

                const parts = line.split(',');
                if (parts.length < 2) continue;

                if (!isDataSection) {
                    const key = parts[0].trim();
                    const val = parts[1].trim();
                    
                    switch(key) {
                        case 'Center_Yaw': newCenterOffset.yaw = parseFloat(val); break;
                        case 'Center_Pitch': newCenterOffset.pitch = parseFloat(val); break;
                        case 'Smoothing': newSmoothing = parseFloat(val); break;
                        case 'Trigger_Radius_Global': newTriggerRadius = parseInt(val); break;
                        case 'Sound_Instrument': newSoundSettings.instrument = val; break;
                        case 'Sound_Volume': newSoundSettings.volume = parseFloat(val); break;
                        case 'Sound_Duration': newSoundSettings.duration = parseFloat(val); break;
                        case 'Sound_ReturnToCenter': newSoundSettings.returnToCenter = (val === 'true'); break;
                        case 'Mouth_Control_Enabled': newMouthEnabled = (val === 'true'); break;
                        case 'Mouth_Trigger_Mode': newMouthTrigger = val; break;
                    }
                } else {
                    const id = parseInt(parts[0]);
                    if (id >= 1 && id <= 9) {
                        const yaw = parseFloat(parts[1]);
                        const pitch = parseFloat(parts[2]);
                        if (!isNaN(yaw) && !isNaN(pitch)) {
                            const rad = parts[3] ? parseInt(parts[3]) : newTriggerRadius;
                            const semi = parts[4] ? parseInt(parts[4]) : 0;
                            const base = (parts[5] && parts[5] !== '') ? parseInt(parts[5]) : DEFAULT_BASE_MIDI[id];
                            const name = parts[6] || NOTE_NAMES[id];

                            newCalibrationData[id] = {
                                yaw: yaw,
                                pitch: pitch,
                                radius: rad,
                                semitoneShift: semi,
                                baseMidi: base,
                                name: name
                            };
                        }
                    }
                }
            }

            centerOffset = newCenterOffset;
            smoothingFactor = newSmoothing;
            defaultTriggerRadius = newTriggerRadius;
            soundSettings = newSoundSettings;
            calibrationData = newCalibrationData;
            mouthControlEnabled = newMouthEnabled;
            mouthTriggerMode = newMouthTrigger;

            speedSlider.value = smoothingFactor;
            radiusSlider.value = defaultTriggerRadius;
            radiusValDisplay.innerText = defaultTriggerRadius;
            
            instrumentSelect.value = soundSettings.instrument;
            volSlider.value = soundSettings.volume * 100;
            volValDisplay.innerText = `${Math.round(soundSettings.volume * 100)}%`;
            durSlider.value = soundSettings.duration;
            durValDisplay.innerText = `${soundSettings.duration}s`;
            returnCenterToggle.checked = soundSettings.returnToCenter;
            
            mouthEnableCheck.checked = mouthControlEnabled;
            mouthTriggerModeSelect.value = mouthTriggerMode;

            saveConfig();
            updateModeDisplay();
            
            document.querySelectorAll('.calib-btn').forEach(btn => btn.classList.remove('recorded'));
            for (let id in calibrationData) {
                const btn = document.getElementById(`btn-${id}`);
                if(btn) btn.classList.add('recorded');
            }

            showFeedback("âœ… CSV åŒ¯å…¥æˆåŠŸï¼");
        }

        function exportCSV() {
            const data = {
                Profile: currentProfileIndex,
                Center_Yaw: centerOffset.yaw.toFixed(4),
                Center_Pitch: centerOffset.pitch.toFixed(4),
                Smoothing: smoothingFactor,
                Trigger_Radius_Global: defaultTriggerRadius,
                Sound_Instrument: soundSettings.instrument,
                Sound_Volume: soundSettings.volume,
                Sound_Duration: soundSettings.duration,
                Sound_ReturnToCenter: soundSettings.returnToCenter,
                Mouth_Control_Enabled: mouthControlEnabled,
                Mouth_Trigger_Mode: mouthTriggerMode
            };
            let csvContent = "\uFEFFParameter,Value\n"; 
            for (const [key, value] of Object.entries(data)) {
                csvContent += `${key},${value}\n`;
            }
            csvContent += "\nID,Yaw,Pitch,Radius,SemitoneShift,BaseMidi,Name\n";
            for (let i = 1; i <= 9; i++) {
                if (calibrationData[i]) {
                    const d = calibrationData[i];
                    const oct = d.semitoneShift || 0;
                    const base = d.baseMidi !== undefined ? d.baseMidi : (DEFAULT_BASE_MIDI[i] || "");
                    csvContent += `${i},${d.yaw.toFixed(4)},${d.pitch.toFixed(4)},${d.radius || defaultTriggerRadius},${oct},${base},${d.name}\n`;
                } else {
                    csvContent += `${i},,,,,,,\n`;
                }
            }
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.setAttribute("href", url);
            const date = new Date().toISOString().slice(0, 10);
            link.setAttribute("download", `head_tracker_profile_${currentProfileIndex}_${date}.csv`);
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            showFeedback("âœ… CSV åŒ¯å‡ºæˆåŠŸï¼");
        }

        function setEditMode(enable) {
            isEditMode = enable;
            if (enable) {
                modeEditBtn.classList.add('active');
                modeEditBtn.style.background = '#3b82f6';
                modeEditBtn.style.color = '#fff';
                modeRecBtn.classList.remove('active-rec');
                modeRecBtn.style.background = '#1f2937';
                modeRecBtn.style.color = '#9ca3af';
                recControls.classList.add('hidden');
                gridHint.innerText = "é»æ“Šä¸‹æ–¹æŒ‰éˆ•ã€Œé¸å–ã€ä¸¦è¨­å®šåƒæ•¸ï¼š";
            } else {
                modeRecBtn.classList.add('active-rec');
                modeRecBtn.style.background = '#ef4444';
                modeRecBtn.style.color = '#fff';
                modeEditBtn.classList.remove('active');
                modeEditBtn.style.background = '#1f2937';
                modeEditBtn.style.color = '#9ca3af';
                recControls.classList.remove('hidden');
                gridHint.innerText = "é»æ“Šä¸‹æ–¹æŒ‰éˆ•ã€ŒéŒ„è£½ã€ä½ç½®ï¼š";
                selectedPointId = null;
                pointSettingsPanel.classList.add('hidden');
                document.querySelectorAll('.calib-btn').forEach(btn => btn.classList.remove('selected'));
            }
        }

        function handleGridClick(id, name) {
            if (isEditMode) {
                selectPoint(id);
            } else {
                recordPose(id, name);
            }
        }

        function selectPoint(id) {
            if (!calibrationData[id]) {
                showFeedback("è«‹å…ˆéŒ„è£½è©²é»æ‰èƒ½ç·¨è¼¯");
                return;
            }
            selectedPointId = id;
            const data = calibrationData[id];
            
            document.querySelectorAll('.calib-btn').forEach(btn => btn.classList.remove('selected'));
            document.getElementById(`btn-${id}`).classList.add('selected');
            
            pointSettingsPanel.classList.remove('hidden');
            selectedPointName.innerText = data.name;
            
            const r = data.radius || defaultTriggerRadius;
            pointRadiusSlider.value = r;
            pointRadiusVal.innerText = r;
            
            const semi = data.semitoneShift || 0;
            updateSemitoneButtons(semi);
            
            const currentBase = data.baseMidi !== undefined ? data.baseMidi : DEFAULT_BASE_MIDI[id];
            baseNoteSelect.value = currentBase !== null ? currentBase : -1;
        }

        function updateSemitoneButtons(val) {
            document.getElementById('semitone-flat-btn').classList.remove('active');
            document.getElementById('semitone-std-btn').classList.remove('active');
            document.getElementById('semitone-sharp-btn').classList.remove('active');
            
            if (val === -1) document.getElementById('semitone-flat-btn').classList.add('active');
            else if (val === 1) document.getElementById('semitone-sharp-btn').classList.add('active');
            else document.getElementById('semitone-std-btn').classList.add('active');
        }

        function setPointSemitone(val) {
            if (selectedPointId && calibrationData[selectedPointId]) {
                calibrationData[selectedPointId].semitoneShift = val;
                updateSemitoneButtons(val);
                saveConfig();
                playNote(0, selectedPointId, true); 
            }
        }
        
        pointRadiusSlider.addEventListener('input', (e) => {
            if (selectedPointId && calibrationData[selectedPointId]) {
                const val = parseInt(e.target.value);
                calibrationData[selectedPointId].radius = val;
                pointRadiusVal.innerText = val;
            }
        });
        pointRadiusSlider.addEventListener('change', saveConfig);

        function toggleCalibration() {
            accompPanel.classList.remove('open'); // é—œé–‰ä¼´å¥é¢æ¿
            calibPanel.classList.toggle('open');
        }

        function toggleAccompPanel() {
            calibPanel.classList.remove('open'); // é—œé–‰æ ¡æ­£é¢æ¿
            accompPanel.classList.toggle('open');
        }

        function toggleSound() {
            if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            if (audioCtx.state === 'suspended') { audioCtx.resume(); }
            isSoundEnabled = !isSoundEnabled;
            if (isSoundEnabled) {
                soundBtn.innerHTML = "<span>ğŸ”Š</span> éŸ³æ•ˆå·²é–‹å•Ÿ";
                soundBtn.classList.add('active');
                playNote(523.25, null, true); 
            } else {
                soundBtn.innerHTML = "<span>ğŸ”‡</span> é»æ“Šé–‹å•ŸéŸ³æ•ˆ (è«‹æª¢æŸ¥éœéŸ³éµ)";
                soundBtn.classList.remove('active');
            }
        }

        soundBtn.addEventListener('touchstart', function(e) {
            e.preventDefault(); toggleSound();
        });

        function playNote(freq, pointId, forcePlay = false) {
            if (!isSoundEnabled || !audioCtx || !freq) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            let baseMidi = 0;
            let finalFreq = freq;

            if (pointId) {
                const savedMidi = calibrationData[pointId]?.baseMidi;
                baseMidi = savedMidi !== undefined ? savedMidi : DEFAULT_BASE_MIDI[pointId];
                
                if(baseMidi !== null) {
                    let shifts = 0;
                    if (isHighOctave) shifts += 12; 
                    if (calibrationData[pointId]) {
                        shifts += (calibrationData[pointId].semitoneShift || 0);
                    }
                    const finalMidi = baseMidi + shifts;
                    finalFreq = 440 * Math.pow(2, (finalMidi - 69) / 12);
                    updateInfoPanel(finalMidi, pointId);
                } else if (!forcePlay) return; // Rest
            } else {
                updateInfoPanel(72, null);
            }
            
            if (finalFreq === 0) return;

            const now = audioCtx.currentTime;
            const vol = soundSettings.volume;
            const dur = soundSettings.duration;
            const inst = soundSettings.instrument;

            const gainNode = audioCtx.createGain();
            gainNode.connect(audioCtx.destination);

            let osc1, osc2;
            if (inst === 'piano') {
                osc1 = audioCtx.createOscillator();
                osc1.type = 'sine'; osc1.frequency.setValueAtTime(finalFreq, now);
                osc2 = audioCtx.createOscillator();
                osc2.type = 'triangle'; osc2.frequency.setValueAtTime(finalFreq, now);
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(vol, now + 0.02);
                gainNode.gain.exponentialRampToValueAtTime(0.001, now + dur);
                osc1.connect(gainNode); osc2.connect(gainNode);
                osc1.start(now); osc1.stop(now + dur);
                osc2.start(now); osc2.stop(now + dur);
            } else if (inst === '8bit') {
                osc1 = audioCtx.createOscillator();
                osc1.type = 'square'; osc1.frequency.setValueAtTime(finalFreq, now);
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(vol * 0.3, now + 0.01);
                gainNode.gain.linearRampToValueAtTime(0, now + 0.1); 
                osc1.connect(gainNode);
                osc1.start(now); osc1.stop(now + 0.1);
            } else if (inst === 'flute') {
                osc1 = audioCtx.createOscillator();
                osc1.type = 'sine'; osc1.frequency.setValueAtTime(finalFreq, now);
                gainNode.gain.setValueAtTime(0, now);
                gainNode.gain.linearRampToValueAtTime(vol * 0.8, now + 0.1); 
                gainNode.gain.linearRampToValueAtTime(0.001, now + dur);
                osc1.connect(gainNode);
                osc1.start(now); osc1.stop(now + dur);
            }
        }

        function toggleOctave() {
            isHighOctave = !isHighOctave;
            if (isHighOctave) {
                octaveIndicator.innerText = "ğŸ¹ éŸ³é«˜: é«˜å…«åº¦ (+8va)";
                octaveIndicator.classList.add("active");
            } else {
                octaveIndicator.innerText = "ğŸ¹ éŸ³é«˜: æ¨™æº–";
                octaveIndicator.classList.remove("active");
            }
        }

        function updateInfoPanel(midi, pointId) {
            const noteIndex = midi % 12;
            const octave = Math.floor(midi / 12) - 1;
            const noteName = NOTE_STRS[noteIndex] + octave;
            const freq = 440 * Math.pow(2, (midi - 69) / 12);
            
            currentNoteNameDisplay.innerText = noteName;
            currentFreqDisplay.innerText = `${freq.toFixed(1)} Hz`;
            if (pointId) currentSolfegeDisplay.innerText = SOLFEGE_MAP[pointId] || "";
            else currentSolfegeDisplay.innerText = "æ¸¬è©¦éŸ³";
            
            noteInfoPanel.style.borderColor = '#e879f9';
            setTimeout(() => { noteInfoPanel.style.borderColor = '#a855f7'; }, 100);
        }

        function toggleDebug() { isDebugVisible = showDebugCheck.checked; }
        function toggleZones() { isZonesVisible = showZonesCheck.checked; }
        
        // æ–°å¢ï¼šåˆ‡æ›å°å¼•æ¡†é¡¯ç¤º
        function toggleGuide() {
            if (showGuideCheck.checked) {
                faceGuide.classList.add('active');
            } else {
                faceGuide.classList.remove('active');
            }
        }

        function setCenter() {
            if (rawYaw !== 0 || rawPitch !== 0) {
                centerOffset.yaw = rawYaw;
                centerOffset.pitch = rawPitch;
                showFeedback("âœ… å·²è¨­å®šç‚ºä¸­å¿ƒï¼");
                saveConfig(); 
            }
        }

        function toggleRangeDetection() {
            isRangeDetecting = !isRangeDetecting;
            if (isRangeDetecting) {
                rangeBtn.innerHTML = "<span>â¹</span> å®Œæˆä¸¦è‡ªå‹•æ ¡æ­£ä¸­å¿ƒ";
                rangeBtn.classList.replace('bg-purple-900/50', 'bg-red-600');
                rangeBtn.classList.replace('border-purple-800', 'border-red-600');
                rangeHint.classList.remove('hidden');
                rangeTrace = [];
                const currentY = normalizeYaw(smoothYaw);
                const currentP = normalizePitch(smoothPitch);
                rangeMinYaw = currentY; rangeMaxYaw = currentY;
                rangeMinPitch = currentP; rangeMaxPitch = currentP;
            } else {
                rangeBtn.innerHTML = "<span>ğŸŒ€</span> é–‹å§‹åœ“å½¢ç¯„åœåµæ¸¬ (æ¨è–¦)";
                rangeBtn.classList.replace('bg-red-600', 'bg-purple-900/50');
                rangeBtn.classList.replace('border-red-600', 'border-purple-800');
                rangeHint.classList.add('hidden');
                generatePointsFromRange();
                showZonesCheck.checked = true;
                isZonesVisible = true;
            }
        }

        function generatePointsFromRange() {
            if (rangeMinYaw === Infinity) return; 
            const driftYaw = (rangeMinYaw + rangeMaxYaw) / 2;
            const driftPitch = (rangeMinPitch + rangeMaxPitch) / 2;
            centerOffset.yaw += driftYaw;
            centerOffset.pitch += driftPitch;
            const spanYaw = (rangeMaxYaw - rangeMinYaw) / 2; 
            const spanPitch = (rangeMaxPitch - rangeMinPitch) / 2;
            const y_left = spanYaw; const y_right = -spanYaw; const y_mid = 0;
            const p_top = -spanPitch; const p_btm = spanPitch; const p_mid = 0;
            const grid = [
                {id: 1, y: y_left, p: p_top, n: 'Do (1)'}, {id: 2, y: y_mid, p: p_top, n: 'Re (2)'}, {id: 3, y: y_right, p: p_top, n: 'Mi (3)'},
                {id: 4, y: y_left, p: p_mid, n: 'Fa (4)'}, {id: 5, y: y_mid, p: p_mid, n: 'ç„¡ (5)'}, {id: 6, y: y_right, p: p_mid, n: 'So (6)'},
                {id: 7, y: y_left, p: p_btm, n: 'La (7)'}, {id: 8, y: y_mid, p: p_btm, n: 'Si (8)'}, {id: 9, y: y_right, p: p_btm, n: 'High Do'}
            ];
            calibrationData = {};
            grid.forEach(pt => {
                calibrationData[pt.id] = { yaw: pt.y, pitch: pt.p, name: pt.n, radius: defaultTriggerRadius };
                const btn = document.getElementById(`btn-${pt.id}`);
                if(btn) btn.classList.add('recorded');
            });
            updateModeDisplay();
            saveConfig(); 
            showFeedback("âœ… å·²è‡ªå‹•æ ¡æ­£ä¸­å¿ƒèˆ‡ç¯„åœï¼");
        }

        function recordPose(id, name) {
            const existing = calibrationData[id] || {};
            calibrationData[id] = { 
                yaw: normalizeYaw(smoothYaw), 
                pitch: normalizePitch(smoothPitch), 
                name: name, 
                radius: existing.radius || defaultTriggerRadius,
                semitoneShift: existing.semitoneShift || 0 
            };
            const btn = document.getElementById(`btn-${id}`);
            if(btn) {
                btn.classList.add('recorded');
                btn.style.background = '#00ffcc'; btn.style.color = '#000';
                setTimeout(() => { btn.style.background = ''; btn.style.color = ''; }, 200);
            }
            updateModeDisplay();
            saveConfig(); 
        }

        function resetCalibration() {
            calibrationData = {}; lastDetectedId = null;
            document.querySelectorAll('.calib-btn').forEach(btn => { btn.classList.remove('recorded'); btn.classList.remove('active'); });
            updateModeDisplay();
            isRangeDetecting = false;
            const key = STORAGE_KEY_PREFIX + currentProfileIndex;
            localStorage.removeItem(key);
            showFeedback(`å·²é‡ç½®è¨­å®šæª” ${currentProfileIndex}`);
        }

        function showFeedback(msg) {
            const oldColor = statusText.style.color;
            const oldText = statusText.innerText;
            statusText.innerText = msg;
            statusText.style.color = "#00ff00";
            setTimeout(() => { 
                if(statusText.innerText === msg) {
                    statusText.innerText = oldText; 
                    statusText.style.color = oldColor; 
                }
            }, 2000);
        }

        function updateModeDisplay() {
            if(!modeIndicator) return;
            const count = Object.keys(calibrationData).length;
            if (count > 0) { modeIndicator.innerText = `æ¨¡å¼: è‡ªå®šç¾© (${count}/9 é»)`; modeIndicator.style.color = '#3b82f6'; } 
            else { modeIndicator.innerText = "æ¨¡å¼: é è¨­é€šç”¨"; modeIndicator.style.color = '#fbbf24'; }
        }

        function updateFPS() {
            const now = performance.now(); frameCount++;
            if (now - lastTime >= 1000) { valFps.innerText = frameCount; frameCount = 0; lastTime = now; }
            requestAnimationFrame(updateFPS);
        }
        updateFPS();

        function mapToCanvas(val, isYaw, width, height) {
            const scale = 1.0; 
            return isYaw ? (val * scale + 0.5) * width : (val * scale + 0.5) * height;
        }
        
        function normalizeYaw(raw) { return raw - centerOffset.yaw; }
        function normalizePitch(raw) { return raw - centerOffset.pitch; }

        function onResults(results) {
            loader.classList.add('hidden');
            const width = videoElement.videoWidth; const height = videoElement.videoHeight;
            canvasElement.width = width; canvasElement.height = height;
            canvasCtx.save(); canvasCtx.clearRect(0, 0, width, height);
            
            if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
                const landmarks = results.multiFaceLandmarks[0];
                drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION, {color: '#C0C0C020', lineWidth: 1});
                
                const nose = landmarks[1], leftEye = landmarks[33], rightEye = landmarks[263], chin = landmarks[152], topHead = landmarks[10];
                const upperLip = landmarks[13], lowerLip = landmarks[14];

                const midEyesX = (leftEye.x + rightEye.x) / 2;
                const faceWidth = Math.abs(rightEye.x - leftEye.x); 
                rawYaw = (nose.x - midEyesX) / faceWidth; 
                
                const midEyesY = (leftEye.y + rightEye.y) / 2;
                const faceHeight = Math.abs(chin.y - topHead.y);
                rawPitch = (nose.y - midEyesY) / faceHeight;

                smoothYaw = smoothYaw * (1 - smoothingFactor) + rawYaw * smoothingFactor;
                smoothPitch = smoothPitch * (1 - smoothingFactor) + rawPitch * smoothingFactor;

                const dispYaw = normalizeYaw(smoothYaw);
                const dispPitch = normalizePitch(smoothPitch);

                valYaw.innerText = dispYaw.toFixed(2); 
                valPitch.innerText = dispPitch.toFixed(2);

                const mouthOpenDist = Math.abs(lowerLip.y - upperLip.y);
                const mouthRatio = mouthOpenDist / faceHeight;
                const isCurrentlyOpen = mouthRatio > MOUTH_OPEN_THRESHOLD;

                // Mouth Control Logic
                if (mouthControlEnabled) {
                    if (mouthTriggerMode === 'open') {
                        if (isCurrentlyOpen && !wasMouthOpen) {
                           toggleOctave();
                        }
                    } else if (mouthTriggerMode === 'close') {
                        if (!isCurrentlyOpen && wasMouthOpen) {
                           toggleOctave();
                        }
                    }
                }
                wasMouthOpen = isCurrentlyOpen;

                if (isDebugVisible) {
                    const ulX = upperLip.x * width;
                    const ulY = upperLip.y * height;
                    const llX = lowerLip.x * width;
                    const llY = lowerLip.y * height;
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(ulX, ulY);
                    canvasCtx.lineTo(llX, llY);
                    canvasCtx.lineWidth = 3;
                    canvasCtx.strokeStyle = isCurrentlyOpen ? "#00ffcc" : "#ff0055"; 
                    canvasCtx.stroke();
                }

                if (isRangeDetecting) {
                    if (dispYaw < rangeMinYaw) rangeMinYaw = dispYaw;
                    if (dispYaw > rangeMaxYaw) rangeMaxYaw = dispYaw;
                    if (dispPitch < rangeMinPitch) rangeMinPitch = dispPitch;
                    if (dispPitch > rangeMaxPitch) rangeMaxPitch = dispPitch;
                    rangeTrace.push({x: dispYaw, y: dispPitch});
                    canvasCtx.fillStyle = "#00ff00";
                    for(let pt of rangeTrace) {
                         const tx = mapToCanvas(pt.x, true, width, height);
                         const ty = mapToCanvas(pt.y, false, width, height);
                         canvasCtx.fillRect(tx, ty, 2, 2);
                    }
                    const x1 = mapToCanvas(rangeMinYaw, true, width, height);
                    const x2 = mapToCanvas(rangeMaxYaw, true, width, height);
                    const y1 = mapToCanvas(rangeMinPitch, false, width, height);
                    const y2 = mapToCanvas(rangeMaxPitch, false, width, height);
                    const bx = Math.min(x1, x2);
                    const by = Math.min(y1, y2);
                    const bw = Math.abs(x1 - x2);
                    const bh = Math.abs(y1 - y2);
                    canvasCtx.strokeStyle = "#00ff00";
                    canvasCtx.lineWidth = 2;
                    canvasCtx.strokeRect(bx, by, bw, bh);
                }

                let detectedId = null; let detectedName = "";
                const curX = mapToCanvas(dispYaw, true, width, height); 
                const curY = mapToCanvas(dispPitch, false, width, height);

                let minDistance = Infinity;
                if (Object.keys(calibrationData).length > 0) {
                    for (const [id, data] of Object.entries(calibrationData)) {
                        const targetX = mapToCanvas(data.yaw, true, width, height);
                        const targetY = mapToCanvas(data.pitch, false, width, height);
                        const dist = Math.sqrt(Math.pow(curX - targetX, 2) + Math.pow(curY - targetY, 2));
                        const r = data.radius || defaultTriggerRadius;
                        if (dist < r) {
                            if (dist < minDistance) {
                                minDistance = dist;
                                detectedId = parseInt(id);
                                detectedName = data.name;
                            }
                        }
                    }
                }

                if (isZonesVisible && !isRangeDetecting && Object.keys(calibrationData).length > 0) {
                    for (const [id, data] of Object.entries(calibrationData)) {
                        const cx = mapToCanvas(data.yaw, true, width, height);
                        const cy = mapToCanvas(data.pitch, false, width, height);
                        const pid = parseInt(id);
                        const isActive = (pid === detectedId);
                        const r = data.radius || defaultTriggerRadius;
                        
                        const shift = data.semitoneShift || 0;
                        
                        canvasCtx.beginPath();
                        canvasCtx.arc(cx, cy, r, 0, 2 * Math.PI);
                        if (pid === 5) {
                            canvasCtx.fillStyle = isActive ? "rgba(0, 255, 204, 0.4)" : "rgba(0, 255, 204, 0.15)";
                            canvasCtx.strokeStyle = "#00ffcc";
                        } else {
                            if (shift === 1) canvasCtx.strokeStyle = "#fbbf24"; 
                            else if (shift === -1) canvasCtx.strokeStyle = "#3b82f6";
                            else canvasCtx.strokeStyle = "#d946ef";
                            
                            canvasCtx.fillStyle = isActive ? "rgba(217, 70, 239, 0.4)" : "rgba(217, 70, 239, 0.1)"; 
                        }
                        canvasCtx.fill();
                        canvasCtx.lineWidth = (id == selectedPointId && isEditMode) ? 4 : 2; 
                        canvasCtx.stroke();
                        
                        canvasCtx.fillStyle = "#fff";
                        canvasCtx.font = "bold 12px Arial";
                        canvasCtx.textAlign = "center";
                        canvasCtx.textBaseline = "middle";
                        
                        let label = pid.toString();
                        if(shift > 0) label += "â™¯";
                        if(shift < 0) label += "â™­";
                        
                        canvasCtx.save();
                        canvasCtx.translate(cx, cy);
                        canvasCtx.scale(-1, 1);
                        canvasCtx.fillText(label, 0, 0);
                        canvasCtx.restore();
                    }
                }

                if (isDebugVisible) {
                    canvasCtx.beginPath(); canvasCtx.arc(curX, curY, 8, 0, 2 * Math.PI); 
                    canvasCtx.fillStyle = "#ff0055"; canvasCtx.fill();
                }

                if (detectedId !== null) {
                    if (detectedId === 5) {
                        isArmed = true;
                        triggerStateText.innerText = "å°±ç·’ (å·²å›ä¸­)";
                        triggerStateText.style.color = "#00ffcc";
                        lastDetectedId = 5;
                    } else if (detectedId !== lastDetectedId) {
                        if (isArmed || !soundSettings.returnToCenter) {
                            playNote(NOTE_FREQS[detectedId], detectedId);
                            if (soundSettings.returnToCenter) {
                                isArmed = false;
                                triggerStateText.innerText = "å·²è§¸ç™¼ (è«‹å›ä¸­é–“)";
                                triggerStateText.style.color = "#fbbf24";
                            }
                        }
                        lastDetectedId = detectedId;
                    }
                }

                statusText.innerText = detectedId ? `${detectedId}. ${detectedName}` : "ç§»å‹•ä¸­...";
                if (detectedId === 5) statusText.style.color = "#00ffcc";
                else if (detectedId) statusText.style.color = "#d946ef";
                else statusText.style.color = "#888";

            } else {
                statusText.innerText = "æœªåµæ¸¬åˆ°è‡‰éƒ¨"; statusText.style.color = "#888";
            }
            canvasCtx.restore();
        }

        // [é›¢ç·šç‰ˆèªªæ˜]
        // è«‹å°‡ä¸‹æ–¹çš„ locateFile å‡½å¼ä¿®æ”¹ç‚º return file; ä»¥æ”¯æ´é›¢ç·šä½¿ç”¨
        const faceMesh = new FaceMesh({locateFile: (file) => {
            // ç·šä¸Šé è¦½ (è«‹è¨»è§£ä¸‹æ–¹è¡Œï¼Œå–æ¶ˆè¨»è§£æ­¤è¡Œ)
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
            // é›¢ç·šç‰ˆ (è«‹å–æ¶ˆè¨»è§£æ­¤è¡Œ)
            // return file;
        }});

        faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        faceMesh.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => { await faceMesh.send({image: videoElement}); },
            width: 640, height: 480
        });
        camera.start().catch(err => { console.error(err); loader.innerHTML = `<div style="color:red">Error: ${err.message}</div>`; });

        // Auto load on start
        setTimeout(loadConfig, 1000);

    </script>
</body>
</html>
